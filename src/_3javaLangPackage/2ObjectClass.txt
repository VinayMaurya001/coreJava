Java.lang.Object
Every Java classes is subclass of Object class either directly or indirectly. 
	It contains most commonly required methods for every class(whether it is predefined in java package or customized class). 
	Hence Object class is considered as root of all Java classes.
	
Either directly or indirectly, w.r.t. classes., Java does not provide multiple inheritance support.
	If our class does not extends any other class then only our class is the direct child class of object class.
	If our class extends any other class then our class is the indirect child class of object class.

Object class methods
	public String toString()
	public native int hashCode()
	public Boolean equals(Object o)
	
	protected native Object clone()  throws CloneNotSupportedException
	protected void finalize() throws Throwable
	public final Class getClass()
	
	public  final void wait() throws InterruptedException
	public final native void wait(long ms) throws InterruptedException
	public final void wait(long ms, int ns) throws InterruptedException
	public native final void notify()
	public native final void notifyAll()
	private static native void registerNatives()- internally required for Object class and not available to the child classes. 
												Hence we are not required to consider this method.

Strictly speaking Object class contains 12 methods.
		int count = 0;
		Class c;
		try {
			c = Class.forName("java.lang.Object");
			java.lang.reflect.Method[] m = c.getDeclaredMethods();
			for (java.lang.reflect.Method m1 : m) {
				count++;
				System.out.println(m1.getName());
			}
			System.out.println(count);// 12
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		}

1)
toString() method
	We can use toString() method to get string representation of an Object.
	String s=obj.toString();

Whenever we are trying to print object reference internally toString() method will be called in SOP.
Student s=new Student();
SOP(s);   //Student@64565
SOP(s.toString());//Student@64565

If our class does not contain toString() method then Object class toString() method will be executed.
Class Student 
{
       String name;
       Int rollno;
       Student(String name, int rollno)
       {
               This.name=name;
               This.rollno=rollno;
       }
       PSVM()
       {
          Strudent s1=new Student(“Durga”,101);
          Strudent s2=new Student(“Ravi”,102);
          SOP(s1);//Student@1888759
          SOP(s1.toString());//Student@1888759
          SOP(s2);//Student@6e1408
          SOP(s2.toString());//Student@6e1408
        }
}
public String toString()
{
     return this.getClass().getName()+”@”+Integer.toHexString(this.hashCode());
     //Classname@hashcode in hexadecimal form
}
public String toString()
{
     return “hello”;
}
Based on our requirement we can override toString() method to provide our own string representation.
For example: Whenever we are trying to print Student object reference, 
	to print his name and rollno, we have to override toString() method as follows:
public String toString()
{
   Return “This is the student with the name:”+name+ “and Rollno: ”+ rollno;
}


toString() method is overridden:
	In all wrapper classes, 
	all collection classes, 
	String class, 
	StringBuffer class and 
	StringBuilder class, 
 	for meaningful String representation. 
 	Hence it is highly recommended to override toString() method in our classes also.

		Test t = new Test();
		System.out.println(t);
		System.out.println(t.toString());

		Integer i1 = new Integer(10);
		System.out.println(i1.toString());

		ArrayList arrayList = new ArrayList();
		arrayList.add("Sachin");
		arrayList.add("Shalu");
		System.out.println(arrayList);

		String str = new String("Hello World");
		System.out.println(str);
	
2)	
public native int hashCode() method
We cannot override address of objects. 
	We can override hashCode() method. 
	Address and  hashCode is 2 diff thing.
It is impossible to know address of java object.
	It is impossible to know size of java object. 
	Java is not machine friendly language like C or C ++.

The purpose of the hashCode() method is to provide a numeric representation of an object's contents 
	so as to provide an alternate mechanism to loosely identify it.
	By default the hashCode() returns an integer that represents loosely the internal memory address of the object. 

For every object a unique number(reasonably), generated by JVM.
Hashcode won’t represents address of an object. 
	JVM will use hashCode while saving objects into hashing related data structures, like 
		HashTable 
		HashMap
		HashSet

Hashcode of null is 0;
null.hashCode() throws a NullPointerException
Objects.hashCode() is just a wrapper method, which performs a pre-check for null values, 
	and for reference that is not null, it returns the same value as p2.hashCode() as in this case. 
	Here's the source code of the method:
		public static int hashCode(Object o) {
    		return o != null ? o.hashCode() : 0;
		}
Why hashcode?
The main advantage of saving objects based on hash code is search operation will become easy.
	The most powerful search algorithm up-to today is hashing.
	Linear Search: o(n)
	Binary Search: o(log2 n)
	Hashing: o(1)

Object class hashCode() method generated hash code based on address of object.
	Hashcode=(int)(13*1232+123/123-addressOfObject)=13223

If we are giving the chance to Object class hashCode() method, 
	it will generate hash code based on address of the object. 
	It does not mean hash code represents address of object.

Based on our requirement we can override hashcode method in our class to generates our own hashcode.
Overriding hashCode() method is said to be proper/appropriate if and only if for every object we have to
	generate a unique number(reasonably) as hash code.


Improper overriding of hashCode() method
public int hashCode()
{
	return 100;
}

Proper overriding of hashCode() method
public int hashCode()
{
	return rollno;
}

toString() vs hashCode()
If we are giving the chance to Object class toString() method, it will internally calls hashCode() method.
If we are overriding toString() method then our toString() method may or may not call hashCode() method.
Case 1:
Class Test
{
	int I;
	Test(int i){
		this.i=I;
	}
	PSVM()
	{
		Test t1=new Test(10);
		Test t2=new Test(100);
		SOP(t1);//Test@123
		SOP(t2);//Test@12334
}
}
//Object:toString()
//Object:hashCode()

Case 2:
Class Test
{
	Int I;
	Test(int i){this.i=I;}
	PSVM()
	{
		Test t1=new Test(10);
		Test t2=new Test(100);
		SOP(t1);//Test@a(a-->10)
		SOP(t2);//Test@64(64-->100)
}
public int hashCode()
{
	return I;
}
}
Object:toString()
Test:hashCode()


Case 3:
Class Test
{
	Int I;
	Test(int i){
	this.I=i;
	}
	PSVM()
	{
		Test t1=new Test(10);
		Test t2=new Test(100);
		SOP(t1);//Test10
		SOP(t2);//Test100
	}
	public int hashCode(){
		return I;
	}
	public String toString(){
		return "Test"+I+””;
	}
}
Test:toString()
hashCode() method won’t executed.	
	

hashCode() by Hand
1)
In the book Effective Java: best practices for the Java platform, 3rd edition Java guru Joshua Bloch describes the following algorithm for implementing your own hashCode() method.
i) comupte the hash of the first deterministic class field used in the implementation of equals(Object) and assign that to a variable I'll call result.
ii) for each remaining deterministic field used the equals(Object) implementation multiply result by 31 and add the hash value of the deterministic field.
public class Person {
    private final String firstName;
    private final String lastName;
    private final LocalDate dob;

 @Override
    public int hashCode() {
        int result = dob == null ? 1 : dob.hashCode();
        result = 31 * result + firstName == null ? 0 : firstName.hashCode();
        result = 31 * result + lastName == null ? 0 : lastName.hashCode();
        return result;
    }
}
2)
  @Override
    public int hashCode() {
        return Objects.hash(dob, firstName, lastName);
    }
3)
Autogeneration with IDE

public final Class getClass() method
It can be used to get runtime class definition of an object.
By using this Class class object, we can access class level properties, 
	like fully qualified name of the class, methods information, constructor information etc.
Object o=al.get(0);
Class c=o.getClass();
SOP(c.getName());
Method[] m=c.getDeclaredMethods();
For(method m1:m)
{
	SOP(m1.getName());
}
To display database vender specific connection interface implemented class name.
Connection conn=DriverManager.getConnection();
SOP(conn.getClass().getName());
Note:
After loading every .class file, JVM created an object of java.lang.Class in the heap area
Programmers can use this Class object to get class level information.
We can use getClass() method very frequently in reflection API.



Protected void finalize() method
JVM ask last wish to object before destroying an object.
Finalize(){	Cleanup activities }
Just before destroying an object , Garbage collector calls finalize method to perform cleanup activity.
Once finalize() method completes, automatically garbage collector destroys that object.

Wait(), notify(), notifyAll()
We can use these methods for inter-thread communication.
The thread which is expecting updation, it is responsible to call wait() method
	then immediately that thread entered into waiting state. 
The thread which is responsible to perform updation, after performing updation, 
	the thread can call notify() method. 
The waiting thread will get that notification and continue its execution with those updates.

clone() method
equals() method
	
	
Summary
11 methods =6+5+1


