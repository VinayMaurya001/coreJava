Instance block-for each object activity, before Initialization- Declaration time
Constructor-initialization, later

Need of constructor
Once we create an object, it is highly recommended to go for an initialization 
because  after initialization only, object will be in position to respond properly.
It is never recommended to perform initialization at the time of variable declaration.
It is never recommended to perform initialization inside instance block.
It is never recommended to perform initialization, for each property respectively.
Whenever we are creating an object, some piece of code will be execute automatically, to perform initialization of the object. 
This piece of the code is nothing but constructor.
Hence the main purpose of constructor is to perform initialization of an object, but not to create object.
public class Test
{
	String name;
	int rollNo;
	Test(String name, int rollNo){
		this.name=name;
		this.rollNo=rollNo;
	}
	public static void main(String args[]){
		Test t1=new Test("durga",101);
		Test t2=new Test("bhatia",201);
	}
}

Difference b/w constructor & instance block
The main purpose of constructor is to perform initialization of an object.
But other than initialization, if we want to perform any activity for every object creation,then we should go for instance block 
(like updating one entry in the database for every object creation or incrementing count value for every object creation).

Both constructor & instance block have, their own different purposes and replacing one concept with another concept, may not work always.
Both constructor & instance block will be executed for every object creation 
   but instance block first followed by constructor.
public class Test{
	static int count=0;
	Test(){		
		count++;	
	}
	Test(int i)	{		
		count++;	
	}
	public static void main(String args[]){
		Test t1=new Test();
		Test t2=new Test(201);
		System.out.println("No of object created: "+count);
	}
}


Rules of writing constructors
1: Name of the class and name of the constructor must be match.
2: return type concept is not applicable for constructor , not even void.
   By mistake if we are trying to declare, return type for the constructor, then we wonn’t get any CTE, 
	because compiler treats it as a method. Hence it is legal (but not recommended) to have a method, whose name is exactly same as class name.
    Class Test{
	void test()//it is a method, not constructor
	{
	}
  }
3: The only  applicable modifier for constructors are public, private, protected, default. 
	If we are trying to use any other modifier, we will get CTE.
    Class Test{
		Static Test()//CTE, modifier static not allowed here
		{}
   }

Default Constructor
Compiler will generate default constructor only if we are not defining any constructor.
Compiler is responsible to generate default constructor and it is always no-arg constructor.
Every class in java can contain constructor. It may be default constructor generated by compiler 
   or customized constructor explicitly provided by programmer but not both simultaneously.
   
 
Prototype of default constructor
Default constructor is always created by compiler.
Default constructor is always no-arg constructor. Every no-arg constructor is not a default constructor.
Access modifier of default constructor is always same like access modifier of class. This rule is applicable only for public and default.
Default constructor contains only one line super()(It is a no-arg call to super class constructor).

Programmer’s code and compiler generated code
Example 1:
Class Test{
}
Class Test{
	Test(){
		Super();
	}
}
Example 2:
Public Class Test{}
Public Class Test{
	Public Test(){
		Super();
	}
}
Example 3:
Public Class Test{
	Void Test(){}
}
Public Class Test{
	Public Test(){Super();}
	Void Test(){}
}


Example 4:
The first line inside every constructor should be either super() or this();
If we are not defining anything, compiler will always place super();
Public Class Test{
Test(){}
}
Public Class Test{
	Test(){Super();}
}


Example 5:
Public Class Test{
	Test(){super();}
}
Public Class Test{
	Test(){Super();}
}


Example 6:
Public Class Test{
	Test(){this(10);}
	Test(int i){}
}
Public Class Test{
	Test(){this(10);}
	Test(int i){
		Super();
	}
}


Case 1:
We can take super() or this(), only in first line of constructor.
 If we are trying to take anywhere else we will get CTE.
Public Class Test{
	Test(){
		SOP(“hi”);
		super(10);//CTE, call to super must be first statement in constructor.
	}
}

Case 2:
Within the constructor, we can take either super() or this() but not both simultaneously.
Class Test{
	Test(){
		Super();
		This();//CTE, call to this must be first statement in constructor.
	}
}

Case 3:
We can use super() or this() only inside constructor. 
If we are trying to use outside of constructor, we will get CTE. 
That is we can call a constructor directly from another constructor only.
Class Test{
	Public void m1(){
		Super();//CTE,call to suoer() must be first statement in constructor
		SOP(“helllo”);
	}
}


Diff b/w super(), this() and super,this
Super() & this() are constructors call, to call super class & current class constructors. 
super and this are keywords to refer super class and current class instance member.
Class Test{
	PSVmain(){
		SOP(super.hashCode());//CTE, non-static variable super cannot be referenced from a static context.
	}
}
We can use super and this everywhere except static area.
We can use super() and this() only in constructor, only in first line.

We can use super() & this() only once in constructor. 
We can use super & this any number of times. 


Roles of new keyword and constructor
Student s=new Student();
	The main objective of new operator is to create an object.
	The main purpose of constructor is to initialize object.
1st object will be created by using new operator & then initialization will be performed by constructor.
The purpose of constructor is 
	To Initialize an object, not to create an object.
	Whenever we are creating an object after object creation automatically constructor will be executed to initialize that object.
	Object creation by new operator and initialization by constructor.
Student s = new Student("Ram", 101);
Before constructor only object is ready and hence within the constructor we can access object properties like Hash Code.
class Test{
	Test(){
		System.out.println(this);//Test@6e3d60
		System.out.println(this.hashCode());//7224672
	}
	Public static void main(String[] args){
		Test t = new Test();
	}
}


Q)Whenever we are creating child class object whether parent class object will be created or not? And
	Whenever creating child class object, what is the need of executing parent class constructor?
Example1:
In the following program both parent & child constructor executed for child object initialization only.
class Person{
	String name;
	int age;
	Person(String name, int age){
		this.name=name;
		this.age=age;
	}
}
class Student extends Person{
	int rollno;
	int marks;
	Student(String name, int age, int rollno, int marks){
		super(name, age);
		this.rollno=rollno;
		this.marks=marks;
	}
	public static void main(String[] args){
		Student s = new Student("Ram", 92, 101, 98);
	}
}

Example2:
	Whenever we are creating child class object automatically parent class constructor will be executed 
	 but parent class object won't be created.
	The purpose of parent class constructor execution is to initialize child class object only. 
	Of course for the instance variables which are inheriting from parent class.
class P{
	P(){
		System.out.println(this.hashCode());//7224672
	}
}
class C extends P{
	C(){
		System.out.println(this.hashCode());//7224672
	}
} 
class Test{
	public static void main(String[] args){
		C c = new C();
		System.out.println(c.hashCode());//7224672
	}
}
In the above example, whenever we are creating child class object both parent and child constructor will be executed for child object purpose only.


Q)Anyway we can not create object for abstract class either directly or indirectly, 
 But abstract class contain constructor. What is the need?
Q)Anyway we can not create object for abstract class and interface. 
 Abstract class contain constructor but interface does not. Why?
